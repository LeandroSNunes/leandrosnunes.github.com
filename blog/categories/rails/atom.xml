<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Leandro Nunes]]></title>
  <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://LeandroSNunes.github.com/leandrosnunes/"/>
  <updated>2015-01-12T01:56:04+00:00</updated>
  <id>http://LeandroSNunes.github.com/leandrosnunes/</id>
  <author>
    <name><![CDATA[Leandro Nunes]]></name>
    <email><![CDATA[leandronunes.dev@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Padrões para desenvolvimento com Rails]]></title>
    <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/2013/02/11/padroes-para-desenvolvimento-com-rails/"/>
    <updated>2013-02-11T18:31:00+00:00</updated>
    <id>http://LeandroSNunes.github.com/leandrosnunes/blog/2013/02/11/padroes-para-desenvolvimento-com-rails</id>
    <content type="html"><![CDATA[<p>Todos nós gostamos (ou não) de codar com clareza e organização, dessa forma podemos dar possibilidades à terceiros e a nós mesmos
de efetuar manutenções no programa que desenvolvemos. Quando se trata de equipe de desenvolvimento, algumas regras
deveriam ser explícita e revisadas cotidianamente, pois a curva de entendimento para um novo dev no projeto pode ser
alta e em alguns casos, ficar com um a menos no time resulta na entrega de software mais rápido que ambientar um novo dev.</p>

<!-- more -->


<p>Pensando nesses conceitos, encontrei o artigo <a href="https://github.com/hopsoft/rails_standards/tree/rails-3-2"><em>Rails 3.2 Development Standards Guide</em></a>
do <a href="https://github.com/hopsoft">Nathan Hopkins</a> que baseando-se em princípios como o
<a href="http://en.wikipedia.org/wiki/You_ain't_gonna_need_it">YAGNI</a> e  <a href="http://en.wikipedia.org/wiki/KISS_principle">KISS</a> elaborou alguns
padrões a seguir quando se desenvolve em Rails, achei bastante interessante e resolvir compartilhar. Vejamos:</p>

<h2>Introdução</h2>

<p>Aplicar os princípios <a href="http://en.wikipedia.org/wiki/You_ain't_gonna_need_it">YAGNI</a> e
<a href="http://en.wikipedia.org/wiki/KISS_principle">KISS</a> para:.</p>

<ul>
<li>Arquitetura Geral</li>
<li>Produtos e Recursos da API</li>
<li>Implementações Específicas</li>
</ul>


<h2>Arquivos</h2>

<ul>
<li>Deve ser usado espaços e não tabs</li>
<li>Tabs devem ser iguais a dois espaços</li>
<li>Finais de linha no padrão Unix (\n)</li>
<li>Usar UTF-8 encoding</li>
</ul>


<h2>Documentação</h2>

<p>Faça um esforço para o código ser auto-explicativo.</p>

<ul>
<li>Prefira nomes descritivos em seu código. Por exemplo <code>user_count</code> é um nome melhor do que <code>len</code>.</li>
<li>Use comentários <a href="http://yardoc.org/">YARD</a> quando a documentação do código for considerado necessária.</li>
<li>Evite comentários no método quando ele for muito complexo; <em>refatoração</em> é melhor.</li>
</ul>


<h2>Diretrizes Gerais</h2>

<p>Essas diretrizes são baseadas nas regras de programação de <a href="http://sandimetz.com/">Sandi Metz</a> introduzidas no Ruby Rogues.
As regras são propositalmente agressiva e são projetadas para dar-lhe uma pausa para que o seu app não corra solto.
Espera-se que você vai quebrá-las por razões pragmáticas ... muito. Veja a nota na YAGNI e KISS.</p>

<ul>
<li>Classes não podem ter mais de 100 linhas de código.</li>
<li>Métodos não podem ser maior do que cinco linhas de código.</li>
<li>Os métodos podem ter no máximo 4 parâmetros.</li>
<li>Controllers só devem instanciar um objeto.</li>
<li>Views só devem ter acesso a uma variável de instância.</li>
<li>Nunca diretamente referêncie uma outra classe/módulo de dentro de uma classe. Estas referências devem ser passado por parâmetros.</li>
</ul>


<p><em>Seja atencioso ao aplicar estas regras. Se você está lutando contra o quadro (no caso de Scrum, Kaban, etc..), é hora de ser um pouco mais pragmático.</em></p>

<h2>Models</h2>

<ul>
<li>Nunca use finders dinâmicos. por exemplo <code>find_by_ …</code></li>
<li>Seja atencioso sobre o uso de callbacks e observers que podem levar ao acoplamento indesejado.</li>
</ul>


<p>Todos os modelos devem ser organizadas usando o seguinte formato:</p>

<p>{% codeblock ruby lang:ruby %}
class MyModel &lt; ActiveRecord::Base
  # extends ...................................................................
  # includes ..................................................................
  # security (i.e. attr_accessible) ...........................................
  # relationships .............................................................
  # validations ...............................................................
  # callbacks .................................................................
  # scopes ....................................................................
  # additional config .........................................................
  # class methods .............................................................
  # public instance methods ...................................................
  # protected instance methods ................................................
  # private instance methods ..................................................
end
{% endcodeblock %}</p>

<p><em>OBS: Os comentários listados acima deve existir no arquivo para servir como um lembrete visual do formato.</em></p>

<h2>Implementação de Models</h2>

<p>É geralmente uma boa idéia isolar diferentes obrigações em módulos separados.
Recomendamos o uso de Concerns como descrito neste <a href="http://37signals.com/svn/posts/3372-put-chubby-models-on-a-diet-with-concerns">post do blog</a>.</p>

<p>{% codeblock Project %}
|-project
  |-app</p>

<pre><code>|-assets
|-controllers
|-helpers
|-mailers
|-models
  |-concerns &lt;-----
|-views
</code></pre>

<p>{% endcodeblock %}</p>

<h3>Orientações</h3>

<ul>
<li>Operações CRUD que estão limitados a um único modelo deve ser implementada no modelo. Por exemplo, um método <code>full_name</code>
que concatena <code>first_name</code> e <code>last_name</code></li>
<li>Operações CRUD que ultrapassam este modelo devem ser implementadas como uma Concern. Por exemplo, um método <code>status</code> que
precisa olhar para vários outros modelos.</li>
<li>Operações simples não CRUD, devem ser implementadas como uma Concern.</li>
<li>Importante! Concerns devem ser isolados e independentes. Eles não devem fazer suposições sobre como o receiver é composto
em tempo de execução. É inaceitável que uma concern invoque métodos definidos em outras concerns, no entanto, invocando
métodos definidos no receiver pretendido é permitido.</li>
<li>Operações complexas multi-step devem ser implementadas como um processo. Veja abaixo.</li>
</ul>


<h2>Controllers</h2>

<p>Controladores devem higienizar parâmetros antes de realizar qualquer outra lógica. A solução preferida é inspirada por esta
<a href="https://gist.github.com/dhh/1975644">essência do DHH</a>.</p>

<p>Aqui está um exemplo de higienização de parâmetros.</p>

<p>{% codeblock ruby lang:ruby %}
class ExampleController &lt; ActionController::Base
  def create</p>

<pre><code>Example.create(sanitized_params)
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>Example.find(params[:id]).update_attributes!(sanitized_params)
</code></pre>

<p>  end</p>

<p>  protected</p>

<p>  def sanitized_params</p>

<pre><code>params[:example].slice(:expected_param, :another_expected_param)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<h2>Processos</h2>

<p>Um processo é definido como uma operação multi-step, que inclui qualquer um dos seguintes itens.</p>

<ul>
<li>Uma transação com uma tarefa complexa está sendo realizada.</li>
<li>Uma chamada feita para um serviço externo.</li>
<li>Qualquer interação no nível do sistema operacional é executada.</li>
<li>O envio de e-mails, a exportação de arquivos, etc ..</li>
</ul>


<p>Em uma tentativa de gerir melhor os processos, nós seguimos vagamente alguns princípios de Domain Driven Development (DDD).
Ou seja, nós adicionamos um diretório <code>processes</code> em <code>app</code> para realizar implementações de nossos processos.</p>

<p>{% codeblock Project %}
|-project
  |-app</p>

<pre><code>|-assets
|-controllers
|-helpers
|-mailers
|-models
|-processes &lt;-----
|-views
</code></pre>

<p>{% endcodeblock %}</p>

<p>Recomendamos o uso de uma ferramenta como o <a href="https://github.com/hopsoft/hero">Hero</a> para ajudar
a modelar esses processos.</p>

<p><strong>Importante:</strong> Não use model ou controller callbacks para invocar um processo. Em vez disso, invocar processos diretamente
do controlador.</p>

<h2>Logging</h2>

<p>Nós usamos a gem <a href="https://github.com/rudionrails/yell">Yell</a> para registro. Aqui está um exemplo de configuração.</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>example/config/application.rb</h1>

<p>module Example
  class Application &lt; Rails::Application</p>

<pre><code>log_levels = [:debug, :info, :warn, :error, :fatal]

# %m : The message to be logged
# %d : The ISO8601 Timestamp
# %L : The log level, e.g INFO, WARN
# %l : The log level (short), e.g. I, W
# %p : The PID of the process from where the log event occured
# %t : The Thread ID from where the log event occured
# %h : The hostname of the machine from where the log event occured
# %f : The filename from where the log event occured
# %n : The line number of the file from where the log event occured
# %F : The filename with path from where the log event occured
# %M : The method where the log event occured
log_format = Yell.format( "[%d] [%L] [%h][%p][%t] [%F:%n:%M] %m")

config.logger = Yell.new do |logger|
  logger.adapter STDOUT, :level =&gt; log_levels, :format =&gt; log_format
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<h2>Extensions &amp; Monkey Patches</h2>

<ul>
<li>Seja pensativo sobre monkey patching e procure primeiro soluções alternativas.</li>
<li>Use um inicializador para carregar extensions e monkey patches.</li>
</ul>


<p>Todas as extensions e monkey patches deve estar em um diretório de extensões em lib.</p>

<p>{% codeblock Project %}
|-project
  |-app
  |-config
  |-db
  |-lib</p>

<pre><code>|-extensions &lt;-----
</code></pre>

<p>{% endcodeblock %}</p>

<p>Use módulos para estender objetos ou adicionar monkey patches. Isto fornece alguma consistência quando você precisa
para rastrear bugs.</p>

<p>Aqui está um exemplo:</p>

<p>{% codeblock ruby lang:ruby %}
module CowboyString
  def downcase</p>

<pre><code>self.upcase
</code></pre>

<p>  end
end
::String.send(:include, CowboyString)
String.ancestors # => [String, CowboyString, Enumerable, Comparable, Object, Kernel]
{% endcodeblock %}</p>

<h2>Dependências de Gems</h2>

<p>Dependências de gems deve ser fixadas antes de implantar no aplicativo de produção. Isto vai garantir a estabilidade da aplicação.</p>

<p>Recomendamos o uso de <a href="http://gembundler.com/v1.2/gemfile.html">gerenciadores de dependência</a>. Ao utilizar um gerenciador de
dependência, certifique-se de especificar pelo menos as versões maiores ou menores. Aqui está um exemplo.</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>Gemfile</h1>

<p>gem 'rails', '3.2.11' # GOOD: exact
gem 'pg', '~>0.9'     # GOOD: tilde
gem 'yell', '>=1.2'   # BAD: unspecific
gem 'nokogiri'        # BAD: unversioned
{% endcodeblock %}</p>

<p>Bundler's Gemfile.lock resolve o mesmo problema, mas nós descobrimos que as atualizações indevidas do pacote podem causar problemas.
É muito melhor ser explícito no Gemfile para garantir a estabilidade do aplicativo.</p>

<p><strong>This will cause your project to slowy drift away from the bleeding edge</strong>. A estratégia deve ser empregada para garantir que o
projeto não se desvie muito do comportamento da versão da gem. Por exemplo, atualizar as gems regularmente (a cada 3-4 meses) e
ser vigilantes sobre os patches de segurança. Serviços como <a href="https://gemnasium.com/">Gemnasium</a> pode ajudar com isso.</p>

<h2>Uma nota sobre Frameworks frontend</h2>

<p>Coisas interessantes estão acontecendo no mundo dos frameworks frontend.</p>

<ul>
<li><a href="http://backbonejs.org/">Backbone</a></li>
<li><a href="http://emberjs.com/">Ember</a></li>
<li><a href="http://angularjs.org/">Angular</a></li>
<li><a href="http://knockoutjs.com/">Knockout</a></li>
<li>e muitos outros ...</li>
</ul>


<p>Ser cuidadoso sobre a decisão de usar um framework frontend. Pergunte-se se existe complexidade em manter e se a decisão é certa.
Muitas vezes existem soluções melhores e mais simples.</p>

<p>Leia os seguintes artigos antes de decidir. No final, você deve ser capaz de expressar por que sua decisão é a certa.</p>

<p><a href="http://37signals.com/svn/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui">How Basecamp Next got to be so damn fast without using much client-side UI</a>
<a href="http://layervault.tumblr.com/post/30932219739/rails-in-realtime">Rails in Realtime</a>
<a href="http://layervault.tumblr.com/post/31462727280/rails-in-realtime-part-2">Rails in Realtime, Part 2</a>
Em ambos os casos estar atento a "layout thrashing", <a href="http://kellegous.com/j/2013/01/26/layout-performance/">conforme descrito aqui</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Corrigindo bugs do ambiente de teste de uma Rails Engine Mountable]]></title>
    <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/2012/10/27/corrigindo-erros-do-ambiente-de-teste-de-uma-rails-engine-mountable/"/>
    <updated>2012-10-27T10:12:00+00:00</updated>
    <id>http://LeandroSNunes.github.com/leandrosnunes/blog/2012/10/27/corrigindo-erros-do-ambiente-de-teste-de-uma-rails-engine-mountable</id>
    <content type="html"><![CDATA[<p>Ao tentar executar a suite de testes em uma <a href="http://edgeapi.rubyonrails.org/classes/Rails/Engine.html">Rails Engine</a> fui surpreendido com alguns erros, então partir para campo afim de
descobrir o porquê das coisas não funcionarem convencionalmente como se esperava. Na página <a href="https://github.com/rails/rails/issues?labels=engines&amp;state=open">Issues</a>
 do Rails no <a href="https://github.com/">GitHub</a> vi que se tratava de bugs do Rails mesmo, no meu caso a versão 3.2.8.</p>

<p>Como não era somente um bug para corrigir e não achei um post relacionando todos, depois da garimpada na net, resolvi juntar
tudo e postar aqui.</p>

<p>Vou fazer um exemplo de execução de testes em uma Engine para exemplificar melhor. Nossa mega Engine vai se chamar
Blog (nesse momento estou inspirado), vamos lá então.</p>

<!-- more -->


<blockquote><p>Não vou entrar em detalhes sobre Rails Engine, se você não tem noção nenhuma do que seria isso pode começar aqui: <a href="http://www.akitaonrails.com/2010/05/10/rails-3-introducao-a-engines#.UIqn32lUMzE">http://www.akitaonrails.com/2010/05/10/rails-3-introducao-a-engines#.UIqn32lUMzE</a>  -  (Sto. @AkitaOnRails).</p>

<p>Futuramente (quando a faculdade deixar) pretendo fazer um exemplo para documentar também, ai coloco o link aqui ;)</p></blockquote>

<h2>Criando uma Rails Engine</h2>

<p>Vamos criar nossa app Blog.</p>

<p>{% codeblock bash lang:bash %}
rails plugin new Blog --mountable
cd Blog
{% endcodeblock %}</p>

<p><em>Vimos que criamos uma Engine isolada, dessa forma nossas classes serão englobadas no namespace Blog e criadas dentro de pastas nomeadas
pelo namespace.</em></p>

<p><img src="/images/bug_engine/estrutura.png" alt="Estrutura de pastas" /></p>

<p>Agora vamos gerar um Scaffold para ter o que testar ;P
{% codeblock bash lang:bash %}
rails g scaffold Post title body:text
{% endcodeblock %}</p>

<p>Em uma Engine, temos tarefas rake específicas prefixadas com "app", as que nos interessam nesse momento são as relativas ao banco de dados</p>

<p>{% codeblock bash lang:bash %}
rake -T db</p>

<p>rake app:db:create # Create the database from config/database.yml for the current Rails.env (use db:create:all to create all dbs in the config)
rake app:db:drop # Drops the database for the current Rails.env (use db:drop:all to drop all databases)
rake app:db:fixtures:load # Load fixtures into the current environment's database.
rake app:db:migrate # Migrate the database (options: VERSION=x, VERBOSE=false).
rake app:db:migrate:status # Display status of migrations
rake app:db:rollback # Rolls the schema back to the previous version (specify steps w/ STEP=n).
rake app:db:schema:dump # Create a db/schema.rb file that can be portably used against any DB supported by AR
rake app:db:schema:load # Load a schema.rb file into the database
rake app:db:seed # Load the seed data from db/seeds.rb
rake app:db:setup # Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the db first)
rake app:db:structure:dump # Dump the database structure to db/structure.sql. Specify another file with DB_STRUCTURE=db/my_structure.sql
rake app:db:version # Retrieves the current schema version number
rake db:create # Create the database from config/database.yml for the current Rails.env (use db:create:all to create all dbs in the config)
rake db:drop # Drops the database for the current Rails.env (use db:drop:all to drop all databases)
rake db:fixtures:load # Load fixtures into the current environment's database.
rake db:migrate # Migrate the database (options: VERSION=x, VERBOSE=false).
rake db:migrate:status # Display status of migrations
rake db:rollback # Rolls the schema back to the previous version (specify steps w/ STEP=n).
rake db:schema:dump # Create a db/schema.rb file that can be portably used against any DB supported by AR
rake db:schema:load # Load a schema.rb file into the database
rake db:seed # Load the seed data from db/seeds.rb
rake db:setup # Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the db first)
rake db:structure:dump # Dump the database structure to an SQL file
rake db:version # Retrieves the current schema version number
{% endcodeblock %}</p>

<p>Vamos criar nosso DB e executar as migrações</p>

<p>{% codeblock bash lang:bash %}
rake app:db:create
rake app:db:migrate</p>

<p>== CreateBlogPosts: migrating ================================================
-- create_table(:blog_posts)
-> 0.0015s
== CreateBlogPosts: migrated (0.0016s) =======================================
{% endcodeblock %}</p>

<blockquote><p>Observe que a tabela criada é prefixada pelo nome da Engine.</p>

<p>Com o scaffold criamos toda a estrutura para os testes.</p></blockquote>

<p><img src="/images/bug_engine/teste.png" alt="Estrutura de pastas nos testes" /></p>

<p>Enfim, vamos aos erros.</p>

<h2>ERROS</h2>

<p>O scaffold já cria os testes funcionais para CRUD, veja o arquivo <code>test/functional/blog/posts_controller_test.rb</code>,
dessa forma já podemos executar os testes e ver se está tudo funfando.</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>1) NoMethodError: undefined method `posts' for #&lt;Blog::PostsControllerTest:0x007f942c045ed0></h3>

<p>Esse error acontece devido nosso controller tentar carregar as fixtures do post que não foram carregadas/criadas, veja:</p>

<p>{% codeblock ruby lang:ruby %}
module Blog</p>

<pre><code>class PostsControllerTest &lt; ActionController::TestCase
    setup do
        @post = posts(:one)
    end
 end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Você precisa explicitar isso para o <a href="http://api.rubyonrails.org/classes/ActiveSupport/TestCase.html">ActiveSupport::TestCase</a>,
abra o arquivo <code>test/test_helper.rb</code> e adicione: <code>ActiveSupport::TestCase.fixtures :all</code> no contexto onde as fixtures são carregadas.</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>Load fixtures from the engine</h1>

<p>if ActiveSupport::TestCase.method_defined?(:fixture_path=)</p>

<pre><code>ActiveSupport::TestCase.fixture_path = File.expand_path("../fixtures", __FILE__)
ActiveSupport::TestCase.fixtures :all
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>2) ActiveRecord::StatementInvalid: Could not find table 'blog_posts'</h3>

<p>Esse error é devido as convenções não funcionarem aqui, se você reparou o path das fixtures está setado para raiz da pasta fixtures, então vamos alterar.</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>Load fixtures from the engine</h1>

<p>if ActiveSupport::TestCase.method_defined?(:fixture_path=)</p>

<pre><code>ActiveSupport::TestCase.fixture_path = File.expand_path("../fixtures/blog", __FILE__)
ActiveSupport::TestCase.fixtures :all
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>3) ActiveRecord::StatementInvalid: SQLite3::SQLException: no such table: posts: DELETE FROM "posts"</h3>

<p>Como convenção, a fixture post tenta utilizar a tabela post, mais como vimos, estamos "namespaceados" pelo nome da engine,
então precisamos novamente explicitar para o ActiveSupport::TestCase que o objeto utilizado pela fixture post é <code>Blog::Post</code>,
dessa forma o <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">ActiveRecord</a> referencia a tabela correta.</p>

<p>Então adicione mais uma linha no seu test_helper.rb</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>Load fixtures from the engine</h1>

<p>if ActiveSupport::TestCase.method_defined?(:fixture_path=)</p>

<pre><code>ActiveSupport::TestCase.fixture_path = File.expand_path("../fixtures/blog", __FILE__)
ActiveSupport::TestCase.fixtures :all
ActiveSupport::TestCase.set_fixture_class :posts =&gt; Blog::Post
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>4) ActionController::RoutingError: No route matches {:id=>"980190962", :post=>{:body=>"MyText", :title=>"MyString"}, :controller=>"blog/posts", :action=>"update"}</h3>

<p>Vamos observar o arquivo de rotas, <code>config/routes.rb</code></p>

<p>{% codeblock ruby lang:ruby %}
BlogTest::Engine.routes.draw do
   resources :posts
end
{% endcodeblock %}</p>

<p>Realmente não temos a rota 'blog/posts' criada e não devemos criar, pois quando montamos nossa Engine em uma App mãe,
essa rota será criada devido nossa Engine ser isolada (--mountable), então a App precisa diferenciar a requisição ao
controller post da Engine da requisição do controller post dela mesma (caso tenha).</p>

<p>Não sei se expliquei bem, mais é só para justificar o porquê de não alterar esse arquivo.</p>

<p>Para resolver isso, vamos disponibilizar diretamente ao controller_test as rotas.
Em <code>test/functional/blog/posts_controller_test.rb</code> adicione:</p>

<p>{% codeblock bash lang:bash %}
setup do</p>

<pre><code>@post = posts(:one)
@routes = Engine.routes
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Congratulation!</strong></p></blockquote>

<p>Agora nossa suite de teste esta rodando, já podemos trabalhar. :P</p>

<p>Tentei explicar as correções de forma que quem esteja começando no mundo Rails possa entender o que está acontecendo e não
simplesmente copiar e colar o código para correção. Lembrando que também sou um aspirante Rails e estou aberto para correções
neste post caso cometi alguma gafe.</p>

<h2>Referencias</h2>

<ul>
<li><a href="https://github.com/rails/rails/issues/4971">https://github.com/rails/rails/issues/4971</a></li>
<li><a href="https://github.com/rails/rails/issues/6573">https://github.com/rails/rails/issues/6573</a></li>
</ul>


<h2>Mais sobre Engine</h2>

<ul>
<li><a href="http://edgeguides.rubyonrails.org/engines.html">http://edgeguides.rubyonrails.org/engines.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Organizando as Expressões Regulares no Rails]]></title>
    <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/2012/09/22/organizando-as-expressoes-regulares-no-rails/"/>
    <updated>2012-09-22T14:55:00+00:00</updated>
    <id>http://LeandroSNunes.github.com/leandrosnunes/blog/2012/09/22/organizando-as-expressoes-regulares-no-rails</id>
    <content type="html"><![CDATA[<p>No dia a dia sempre necessitamos dos super poderes das Expressões Regulares para validações de formulários, replaces em
textos e tantas outras coisas mais, alguns patterns raramente mudam de um projeto para outro, o pattern para validar e-mails
é um exemplo.</p>

<!-- more -->


<p>Pensando nisso e aproveitando a estrutura do Rails que já possui a pasta <code> /lib </code>  para armazenar nossos códigos customizados,
criei um module "ER" para ir colecionando os patterns rotineiros.</p>

<blockquote><p>Neste post estou mostrando uma solução que encontrei pois ainda desconheço se o Rails possui alguma convenção para essa tarefa.</p></blockquote>

<h2>Vamos ver a ideia!</h2>

<p>Na pasta <code> /lib </code> criei um arquivo <code> er.rb </code>  que será nosso "repositório de ERs".</p>

<p>{% codeblock ruby lang:ruby %}
module ER
  # Pattern para validação de e-mail
  EMAIL = /<sup>[<sup>@][\w.-]+@[\w.-]+[.][a-z]{2,4}$/i</sup></sup>
  # Pattern para validação de data no padrão 99/99/9999
  DATE = /<sup>(([012][0-9])|(3[01]))\/(0[1-9]|1[012])\/\d{4}$/</sup>
  # Pattern para validação de data no padrão 9999-99-99
  DATE_DB = /<sup>\d{4}-(0[1-9]|1[012])-(([012][0-9])|(3[01]))$/</sup>
  # Pattern para validação de horas sem os segungos no padrão 99:99
  TIME_H_M = /<sup>(([01]\d)|(2[0-3])):([0-5]\d)$/</sup>
  # Pattern para validação de urls, permitido os protocolos http e https
  URL = /<sup>(http|https):\/\/[a-z0-9]+([-.]{1}[a-z0-9]+)<em>.[a-z]{2,5}(([0-9]{1,5})?\/.</em>)?$/ix</sup>
end
{% endcodeblock %}</p>

<h2>Utilizando</h2>


<p>Para exemplificar, vamos validar um model User.</p>

<p>{% codeblock ruby lang:ruby %}
require 'er'
class User &lt; ActiveRecord::Base
  attr_accessible :email, :full_name
  validates :email, presence:true,  format:{with: ER::EMAIL}
end
{% endcodeblock %}</p>

<p>Perceberam a chamada do pattern? :P</p>

<p>Para validação em front-end utilizando o atributo <code> pattern </code> do HTML5, podemos reaproveitar nossos patterns, só que
precisamos de um passo a mais devido o padrão ser ER crua sem estar contida em "//" (barras).</p>

<p>Criei então um Help para fazer essa tarefa e as View continuarem fazendo apenas seu papel.
No arquivo <code> app/helpers/application_helper.rb </code>  incluir:</p>

<p>{% codeblock ruby lang:ruby %}
def er_for_html(er)
  begin</p>

<pre><code>ER.const_get(er.upcase.to_sym).source
</code></pre>

<p>  rescue NameError => exc</p>

<pre><code>"A expressao solicitada nao existe"
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>Notem que usei <code> Module#const_get </code>  para pegar a referência da constante informado e no fim o
<code> Regexp#source </code>  que retorna a string original que está envolvida por "//" <br />
Ficando no formulário:</p>

<p>{% codeblock ruby lang:ruby %}
&lt;%= f.text_field(:email, :class => :span3, :pattern => er_for_html("email"), :type => :email, :required => true, :title => "E-mail" ) %></p>

<p>{% endcodeblock %}</p>

<h2>Concluíndo</h2>


<p>É isso ai, a intenção é só para mostar uma possibilidade de organizar as coisas, claro que deve possuir outras, dessa forma,
aceito sugestões e dicas. :)</p>

<p>Para uma consulta rápida sobre metacaracteres o Aurélio disponibiliza um guia rápido <a href="http://piazinho.com.br/download/expressoes-regulares-3-tabelas.pdf" title="Ir para outra página">http://piazinho.com.br/download/expressoes-regulares-3-tabelas.pdf</a>.<br />
Para se aprofundar, leia o livro <a href="http://piazinho.com.br/" title="Ir para página do livro">Expressões Regulares - Uma abordagem divertida</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementando aplicações Rails com Capistrano]]></title>
    <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/2012/04/06/Implementando-aplicacoes-rails-com-capistrano/"/>
    <updated>2012-04-06T17:37:00+00:00</updated>
    <id>http://LeandroSNunes.github.com/leandrosnunes/blog/2012/04/06/Implementando-aplicacoes-rails-com-capistrano</id>
    <content type="html"><![CDATA[<p>
Chegou a hora de implantar a aplicação para os primeiros testes do cliente?<br />
Vamos ver como a dupla sertaneja <a href="http://rubyonrails.org/" title="Framework em Ruby para desenvolvimento de aplicações web">Rails</a> & <a href="http://capistranorb.com/">Capistrano</a> soam bem nesta tarefa.
</p>


<!-- more -->


<p>
O Capistrano é uma gem para implantar (deploy) aplicações web. Inicialmente desenvolvida para Rails, 
tem a finalidade de enviar seu código fonte para um servidor web e permitir o versionamento, ou seja, 
te dando super poderes para voltar a versão anterior do seu código caso algo dê errado na versão atual. 
Com um pouquinho de configuração o Capistrano pode ser utilizado para outros framework/linguagem. 
</p>




<p>
Vamos adimitir que você já tenha conhecimento em Sistemas de Controle de Versão (<a href="http://github.com/" title="Sistema de controle de versão distribuído">Git</a>, <a href="http://subversion.apache.org/" title="Sistema de controle de versão centralizado" >SVN</a>, etc) e que seu 
ambiente de desenvolvimento esteja funfando com a aplicação.
</p>


<p><em>Hoje foi o meu primeiro contato com o Capistrano, abaixo segue minhas descobertas.</em></p>

<h2>Requisitos</h2>




<p>
Para executar esta tarefa temos que verificar em nossa maleta de ferramentas se está presente:
</p>


<ul>
    <li><a href="http://www.ruby-lang.org/en/">Ruby</a></li>
    <li>Uma aplicação (no meu caso em Rails)</li>
    <li>Servidor Web com suporte a SSH</li>
    <li>Terminal (bash, sh, etc…)</li>
    <li>Um repositório (No meu caso GIT)</li>
</ul>




<h2>Instalação</h2>


<p>
Como citado, o Capistrano é um gem e com isso você pode instalar do jeito tradicional mesmo. <br />
É, aquele fácil! Fazemos assim:
</p>


<p>{% codeblock bash lang:bash %}
gem install capistrano
{% endcodeblock %}</p>

<p>
O capistrano adiciona alguns utilitários de linha de comando, o <code>cap</code> e <code>capify</code> iremos conhecer mais abaixo.
Também é possível adicionar esta gem no arquivo GemFile do seu projeto.
</p>


<p>{% codeblock ruby lang:ruby %}
gem 'capistrano'
{% endcodeblock %}</p>

<p>
e depois executar o <code>bundle install</code> em seu terminal.
</p>




<h2>Iniciando</h2>


<p>
Agora utilizamos o <code>capify</code> , nosso amigo de linha de comando para fazer com que o Capistrano monitore nossa work area e nos dê opções para configurá-lo. Primeiramente temos que estar na raiz do diretório do nosso projeto.
</p>


<p>{% codeblock bash lang:bash %}
cd /app_rails/
{% endcodeblock %}</p>

<p>Agora é só executar!</p>


<p>{% codeblock bash lang:bash %}
capify .
{% endcodeblock %}</p>

<p>Com isso ganhamos dois arquivos em nosso projeto, são eles:</p>


<ul>
    <li><b>capifile</b> –> Possui referências as bibliotecas usadas pelo Capistrano e é responsável em carregá-las.</li>
    <li><b>config/deploy.rb</b> –> Este possui todas diretrizes para configurar sua implantação, geralmente precisamos editar apenas este.</li>
</ul>




<h2>Confirgurações</h2>


<p>
O Capistrano precisa de algumas informações para que tudo funcione conforme esperamos e isso fazemos editando o arquivo config/deploy.rb. Estou usando um projeto fictício apenas para exemplo, fique atendo as informações que devem ser substituidas conforme as suas configurações.
<br />Vamos lá então!
</p>


<h3>A) Informações do projeto</h3>


<p>{% codeblock ruby lang:ruby %}
set :application, "app_rails"       # O nome do projeto
set :keep_releases, 5               # Isso guardar os 5 últimos deploys
set :rails_env,     "production"    # O ambiente em que o Rails irá atuar
{% endcodeblock %}</p>

<p>
Toda vez que adicionarmos uma nova funcionalidade ao projeto iremos implementá-la no servidor para que outros tenham acesso e nesse processo, o Capistrano faz o versionamento mantendo seu release anterior. Na linha 2 dizemos que será mantido as 5 últimas atualizações, assim caso algo saia errado neste novo release, podemos usar um comandinho salvador da pátria.
</p>


<p>{% codeblock bash lang:bash %}
cap rollback
{% endcodeblock %}</p>

<p>com isso voltamos ao release que estava funfando.</p>




<h3>B) SCM (source code manager)</h3>


<p>{% codeblock ruby lang:ruby %}
set :scm, 'git'
set :repository,  "git@github.com:LeandroSNunes/app_rails.git"
set :branch, 'master'
set :deploy_via, :remote_cache
{% endcodeblock %}</p>

<p>
No meu caso uso Git como repositório e informo na linha 1. A linha 4 é informado ao Capistrano que ele não precisa pegar todo repositório toda vez que subirmos um novo release, ele somente irá buscar as modificações.
</p>


<h3>C) Informações do servidor</h3>


<p>{% codeblock ruby lang:ruby %}
default_run_options[:pty] = true
ssh_options[:forward_agent] = true
set :user, "leandro"
set :use_sudo, false
server "leandronunes.com.br", :web, :app, :db, :primary => true
set :deploy_to, "/www/app_rails.leandronunes.com.br/#{application}"
{% endcodeblock %}</p>

<p>
Na linha 2 permitimos que o SSH carregue nossa chave para o servidor para que de lá seja acessado o github.<br />
O usuário informado precisa ter permissões de escrita no servidor.<br />
Alguns comandos por default são executados com sudo, porém se tiver usando um servidor compartilhado e que não tiver acesso de superusuário, informe para não utilizar o sudo como na linha 4.<br />
O Capistrano entende que sua aplicação irá fazer muito sucesso e que seja preciso distribuí-la em vários servidores, no meu caso estou enviando tudo para o mesmo lugar então a linha 5 é uma forma otimizada de informar isso.
</p>


<p>Caso precise redirecionar serviços para outros servidores, você pode substituir a linha 5 por:</p>


<p>{% codeblock ruby lang:ruby %}
role :web, 'dominio'
role :app, 'dominio'
role :db,  'dominio', :primary => true
{% endcodeblock %}</p>

<h2>Ops! Executando.</h2>


<p>Agora é a hora! Vamos implantar nossa aplicação no servidor, começamos verificando se tudo está OK.</p>


<p>{% codeblock bash lang:bash %}
cap deploy:check
{% endcodeblock %}</p>

<p>Tudo correndo bem, você será informado. Seguindo, criaremos a estrutura de pastas no servidor.</p>


<p>{% codeblock bash lang:bash %}
cap deploy:setup
{% endcodeblock %}</p>

<p>
O que fizemos? Com isso será criado duas pastas (<em>release</em> e <em>shared</em>) e ainda um link simbólico chamado <em>current</em> apontando para o último release. Na pasta releases é criado uma pasta para o deploy efetuado. A pasta shared serve para armazenar arquivos que serão compartilhados entre os releases, como logs, imagens, arquivos de configuração, etc…
</p>


<p>{% blockquote %}
Quando trabalhamos com Rails, Git e mais de um desenvolvedor é de prática adicionar nosso arquivo database.yml ao .gitignore, fazendo com que este não seja monitorado e conseguentemente não enviado para o repositório, assim configuramos um único arquivo de banco de dados e colocamos na pasta shared para que todos releases compartilhem a mesma configuração. Mais abaixo vamos adicionar uma tarefa pra fazer isso.
{% endblockquote %}</p>

<h3>A) Criando tarefas para o Capistrano</h3>


<p>{% codeblock ruby lang:ruby %}
namespace :deploy do</p>

<h1>task :start do ; end</h1>

<h1>task :stop do ; end</h1>

<p>   task :restart, :roles => :app, :except => { :no_release => true } do</p>

<pre><code> run "touch #{current_path}/tmp/restart.txt"
 end
</code></pre>

<p>   task :database, :roles => :app do</p>

<pre><code> run "cp #{deploy_to}/#{shared_dir}/database.yml #{release_path}/config/"
</code></pre>

<p>   end
   task :permission, :roles => [:web, :db, :app] do</p>

<pre><code> run "chmod 755 #{release_path}/public -R" 
</code></pre>

<p>   end
end</p>

<p>namespace :assets do</p>

<pre><code>task :symlink, :roles =&gt; :app do
  assets.create_dir
      run &lt;&lt;-CMD
        rm -rf  #{release_path}/public/images/upload &amp;&amp;
        ln -nfs #{shared_path}/upload #{release_path}/public/images/upload
      CMD
end
    task :create_dir, :roles =&gt; :app do
      run "mkdir -p #{shared_path}/upload"
    end
</code></pre>

<p>end</p>

<p>after "deploy:assets:symlink", 'deploy:database'
after "deploy:update_code", 'deploy:permission'
{% endcodeblock %}</p>

<p>
Ao concluir o deploy é necessário reiniciar o servidor para que as novas configurações entrem em vigor, podemos fazer isso simplesmente atualizando o arquivos <em>tmp/restart.txt</em>, percebam na tarefa restart.
</p>


<p>
Acima adicionamos nosso arquivo database.yml em nossa pasta shared então precisamos adicioná-la dentro do release corrente após o deploy, a tarefa <em>database</em> faz exatamente isso.
</p>


<p>
Na tarefa permissions setamos as permissões necessárias para pasta public.
</p>


<p>
Depois, resolvemos o problemas de aquivos de imagens adicionados pelos usuários (podemos supor um cadastro de produtos). As tarefas dentro de <em>assets</em> criam uma pasta upload dentro de shared e um link simbólico em <em>public/imagens</em> apontando para esta pasta.
</p>




<p>Por fim vamos executar o tão esperado deploy.</p>


<p>{% codeblock bash lang:bash %}
cap deploy:cold
cap deploy
{% endcodeblock %}</p>

<p>
Rodamos o <code>cap deploy:cold</code> primeiro para colocar os arquivos no servido, depois efetuamos o deploy.<br />
A partir da segunda implantação não é necessário rodar <code>cap deploy:cold</code><br />
Se precisar migrar seu banco utilize <code>cap deploy:migrations</code><br />
Alguma coisa fugiu do controle? volte ao release anterior com <code>cap deploy:rollback</code><br />
Para mais informações <code>cap -T</code> para visualizar todas as tarefas do Capistrano.
</p>




<h2>Juntando tudo</h2>


<p>{% codeblock ruby lang:ruby %}</p>

<h1>Projeto</h1>

<p>set :application, "app_rails"       # O nome do projeto
set :keep_releases, 5               # Isso guardar os 5 últimos deploys
set :rails_env,     "production"    # O ambiente em que o Rails irá atuar</p>

<h1>SCM</h1>

<p>set :scm, 'git'
set :repository,  "git@github.com:LeandroSNunes/app_rails.git"
set :branch, 'master'
set :deploy_via, :remote_cache</p>

<h1>Servidor</h1>

<p>default_run_options[:pty] = true
ssh_options[:forward_agent] = true
set :user, "leandro"
set :use_sudo, false
server "leandronunes.com.br", :web, :app, :db, :primary => true
set :deploy_to, "/www/app_rails.leandronunes.com.br/#{application}"</p>

<h1>Tarefas</h1>

<p>namespace :deploy do</p>

<h1>task :start do ; end</h1>

<h1>task :stop do ; end</h1>

<p>   task :restart, :roles => :app, :except => { :no_release => true } do</p>

<pre><code> run "touch #{current_path}/tmp/restart.txt"
 end
</code></pre>

<p>   task :database, :roles => :app do</p>

<pre><code> run "cp #{deploy_to}/#{shared_dir}/database.yml #{release_path}/config/"
</code></pre>

<p>   end
   task :permission, :roles => [:web, :db, :app] do</p>

<pre><code> run "chmod 755 #{release_path}/public -R" 
</code></pre>

<p>   end
end</p>

<p>namespace :assets do</p>

<pre><code>task :symlink, :roles =&gt; :app do
  assets.create_dir
      run &lt;&lt;-CMD
        rm -rf  #{release_path}/public/images/upload &amp;&amp;
        ln -nfs #{shared_path}/upload #{release_path}/public/images/upload
      CMD
end
    task :create_dir, :roles =&gt; :app do
      run "mkdir -p #{shared_path}/upload"
    end
</code></pre>

<p>end</p>

<p>after "deploy:assets:symlink", 'deploy:database'
after "deploy:update_code", 'deploy:permission'
{% endcodeblock %}</p>

<h2>Então...</h2>


<p>
Isso foi minha colheita em um dia de deploy aqui na empresa e basicamente quando for efetuar um deploy da sua aplicação você vai estar neste ciclo novamente:
</p>


<ul>
    <li>Adicionar seu último release em um repositório</li>
    <li>Iniciar o monitoramento do Capistrano no diretório de sua aplicação</li>
    <li>Editar o arquivo de configuração do Capistrano</li>
    <li>Fazer um confere das configurações no servidor</li>
    <li>Montar a estrutura de pastas no servidor</li>
    <li>Fazer deploy de sua aplicação</li>
    <li>Configurar o ambiente de produção</li>
    <li>Cruzar os dedos e atualizar seu navegador</li>
</ul>


<p>
Algumas informações tive acesso dando umas googladas e dois blogs que usei de referências foram 
<a href="http://blog.dmitrynix.com/deploy-capistrano/" >Unix and Me</a> e <a href="http://objetiva.co/blog/2008/06/25/capistrano-com-git-tutorial-bsico" >Objetiva</a>, acessem para visualizarem o conteúdo completo.
</p>


<p>
Para mais informações
<a href="https://github.com/capistrano/capistrano/wiki/_pages">https://github.com/capistrano/capistrano/wiki/_pages</a>
</p>



]]></content>
  </entry>
  
</feed>
