<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Leandro Nunes]]></title>
  <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://LeandroSNunes.github.com/leandrosnunes/"/>
  <updated>2015-01-12T01:56:04+00:00</updated>
  <id>http://LeandroSNunes.github.com/leandrosnunes/</id>
  <author>
    <name><![CDATA[Leandro Nunes]]></name>
    <email><![CDATA[leandronunes.dev@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Corrigindo bugs do ambiente de teste de uma Rails Engine Mountable]]></title>
    <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/2012/10/27/corrigindo-erros-do-ambiente-de-teste-de-uma-rails-engine-mountable/"/>
    <updated>2012-10-27T10:12:00+00:00</updated>
    <id>http://LeandroSNunes.github.com/leandrosnunes/blog/2012/10/27/corrigindo-erros-do-ambiente-de-teste-de-uma-rails-engine-mountable</id>
    <content type="html"><![CDATA[<p>Ao tentar executar a suite de testes em uma <a href="http://edgeapi.rubyonrails.org/classes/Rails/Engine.html">Rails Engine</a> fui surpreendido com alguns erros, então partir para campo afim de
descobrir o porquê das coisas não funcionarem convencionalmente como se esperava. Na página <a href="https://github.com/rails/rails/issues?labels=engines&amp;state=open">Issues</a>
 do Rails no <a href="https://github.com/">GitHub</a> vi que se tratava de bugs do Rails mesmo, no meu caso a versão 3.2.8.</p>

<p>Como não era somente um bug para corrigir e não achei um post relacionando todos, depois da garimpada na net, resolvi juntar
tudo e postar aqui.</p>

<p>Vou fazer um exemplo de execução de testes em uma Engine para exemplificar melhor. Nossa mega Engine vai se chamar
Blog (nesse momento estou inspirado), vamos lá então.</p>

<!-- more -->


<blockquote><p>Não vou entrar em detalhes sobre Rails Engine, se você não tem noção nenhuma do que seria isso pode começar aqui: <a href="http://www.akitaonrails.com/2010/05/10/rails-3-introducao-a-engines#.UIqn32lUMzE">http://www.akitaonrails.com/2010/05/10/rails-3-introducao-a-engines#.UIqn32lUMzE</a>  -  (Sto. @AkitaOnRails).</p>

<p>Futuramente (quando a faculdade deixar) pretendo fazer um exemplo para documentar também, ai coloco o link aqui ;)</p></blockquote>

<h2>Criando uma Rails Engine</h2>

<p>Vamos criar nossa app Blog.</p>

<p>{% codeblock bash lang:bash %}
rails plugin new Blog --mountable
cd Blog
{% endcodeblock %}</p>

<p><em>Vimos que criamos uma Engine isolada, dessa forma nossas classes serão englobadas no namespace Blog e criadas dentro de pastas nomeadas
pelo namespace.</em></p>

<p><img src="/images/bug_engine/estrutura.png" alt="Estrutura de pastas" /></p>

<p>Agora vamos gerar um Scaffold para ter o que testar ;P
{% codeblock bash lang:bash %}
rails g scaffold Post title body:text
{% endcodeblock %}</p>

<p>Em uma Engine, temos tarefas rake específicas prefixadas com "app", as que nos interessam nesse momento são as relativas ao banco de dados</p>

<p>{% codeblock bash lang:bash %}
rake -T db</p>

<p>rake app:db:create # Create the database from config/database.yml for the current Rails.env (use db:create:all to create all dbs in the config)
rake app:db:drop # Drops the database for the current Rails.env (use db:drop:all to drop all databases)
rake app:db:fixtures:load # Load fixtures into the current environment's database.
rake app:db:migrate # Migrate the database (options: VERSION=x, VERBOSE=false).
rake app:db:migrate:status # Display status of migrations
rake app:db:rollback # Rolls the schema back to the previous version (specify steps w/ STEP=n).
rake app:db:schema:dump # Create a db/schema.rb file that can be portably used against any DB supported by AR
rake app:db:schema:load # Load a schema.rb file into the database
rake app:db:seed # Load the seed data from db/seeds.rb
rake app:db:setup # Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the db first)
rake app:db:structure:dump # Dump the database structure to db/structure.sql. Specify another file with DB_STRUCTURE=db/my_structure.sql
rake app:db:version # Retrieves the current schema version number
rake db:create # Create the database from config/database.yml for the current Rails.env (use db:create:all to create all dbs in the config)
rake db:drop # Drops the database for the current Rails.env (use db:drop:all to drop all databases)
rake db:fixtures:load # Load fixtures into the current environment's database.
rake db:migrate # Migrate the database (options: VERSION=x, VERBOSE=false).
rake db:migrate:status # Display status of migrations
rake db:rollback # Rolls the schema back to the previous version (specify steps w/ STEP=n).
rake db:schema:dump # Create a db/schema.rb file that can be portably used against any DB supported by AR
rake db:schema:load # Load a schema.rb file into the database
rake db:seed # Load the seed data from db/seeds.rb
rake db:setup # Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the db first)
rake db:structure:dump # Dump the database structure to an SQL file
rake db:version # Retrieves the current schema version number
{% endcodeblock %}</p>

<p>Vamos criar nosso DB e executar as migrações</p>

<p>{% codeblock bash lang:bash %}
rake app:db:create
rake app:db:migrate</p>

<p>== CreateBlogPosts: migrating ================================================
-- create_table(:blog_posts)
-> 0.0015s
== CreateBlogPosts: migrated (0.0016s) =======================================
{% endcodeblock %}</p>

<blockquote><p>Observe que a tabela criada é prefixada pelo nome da Engine.</p>

<p>Com o scaffold criamos toda a estrutura para os testes.</p></blockquote>

<p><img src="/images/bug_engine/teste.png" alt="Estrutura de pastas nos testes" /></p>

<p>Enfim, vamos aos erros.</p>

<h2>ERROS</h2>

<p>O scaffold já cria os testes funcionais para CRUD, veja o arquivo <code>test/functional/blog/posts_controller_test.rb</code>,
dessa forma já podemos executar os testes e ver se está tudo funfando.</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>1) NoMethodError: undefined method `posts' for #&lt;Blog::PostsControllerTest:0x007f942c045ed0></h3>

<p>Esse error acontece devido nosso controller tentar carregar as fixtures do post que não foram carregadas/criadas, veja:</p>

<p>{% codeblock ruby lang:ruby %}
module Blog</p>

<pre><code>class PostsControllerTest &lt; ActionController::TestCase
    setup do
        @post = posts(:one)
    end
 end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Você precisa explicitar isso para o <a href="http://api.rubyonrails.org/classes/ActiveSupport/TestCase.html">ActiveSupport::TestCase</a>,
abra o arquivo <code>test/test_helper.rb</code> e adicione: <code>ActiveSupport::TestCase.fixtures :all</code> no contexto onde as fixtures são carregadas.</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>Load fixtures from the engine</h1>

<p>if ActiveSupport::TestCase.method_defined?(:fixture_path=)</p>

<pre><code>ActiveSupport::TestCase.fixture_path = File.expand_path("../fixtures", __FILE__)
ActiveSupport::TestCase.fixtures :all
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>2) ActiveRecord::StatementInvalid: Could not find table 'blog_posts'</h3>

<p>Esse error é devido as convenções não funcionarem aqui, se você reparou o path das fixtures está setado para raiz da pasta fixtures, então vamos alterar.</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>Load fixtures from the engine</h1>

<p>if ActiveSupport::TestCase.method_defined?(:fixture_path=)</p>

<pre><code>ActiveSupport::TestCase.fixture_path = File.expand_path("../fixtures/blog", __FILE__)
ActiveSupport::TestCase.fixtures :all
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>3) ActiveRecord::StatementInvalid: SQLite3::SQLException: no such table: posts: DELETE FROM "posts"</h3>

<p>Como convenção, a fixture post tenta utilizar a tabela post, mais como vimos, estamos "namespaceados" pelo nome da engine,
então precisamos novamente explicitar para o ActiveSupport::TestCase que o objeto utilizado pela fixture post é <code>Blog::Post</code>,
dessa forma o <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">ActiveRecord</a> referencia a tabela correta.</p>

<p>Então adicione mais uma linha no seu test_helper.rb</p>

<p>{% codeblock ruby lang:ruby %}</p>

<h1>Load fixtures from the engine</h1>

<p>if ActiveSupport::TestCase.method_defined?(:fixture_path=)</p>

<pre><code>ActiveSupport::TestCase.fixture_path = File.expand_path("../fixtures/blog", __FILE__)
ActiveSupport::TestCase.fixtures :all
ActiveSupport::TestCase.set_fixture_class :posts =&gt; Blog::Post
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Ops! deu pau ;(</strong></p></blockquote>

<h3>4) ActionController::RoutingError: No route matches {:id=>"980190962", :post=>{:body=>"MyText", :title=>"MyString"}, :controller=>"blog/posts", :action=>"update"}</h3>

<p>Vamos observar o arquivo de rotas, <code>config/routes.rb</code></p>

<p>{% codeblock ruby lang:ruby %}
BlogTest::Engine.routes.draw do
   resources :posts
end
{% endcodeblock %}</p>

<p>Realmente não temos a rota 'blog/posts' criada e não devemos criar, pois quando montamos nossa Engine em uma App mãe,
essa rota será criada devido nossa Engine ser isolada (--mountable), então a App precisa diferenciar a requisição ao
controller post da Engine da requisição do controller post dela mesma (caso tenha).</p>

<p>Não sei se expliquei bem, mais é só para justificar o porquê de não alterar esse arquivo.</p>

<p>Para resolver isso, vamos disponibilizar diretamente ao controller_test as rotas.
Em <code>test/functional/blog/posts_controller_test.rb</code> adicione:</p>

<p>{% codeblock bash lang:bash %}
setup do</p>

<pre><code>@post = posts(:one)
@routes = Engine.routes
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>Agora rode os testes;</p>

<p>{% codeblock bash lang:bash %}
rake test
{% endcodeblock %}</p>

<blockquote><p><strong>Congratulation!</strong></p></blockquote>

<p>Agora nossa suite de teste esta rodando, já podemos trabalhar. :P</p>

<p>Tentei explicar as correções de forma que quem esteja começando no mundo Rails possa entender o que está acontecendo e não
simplesmente copiar e colar o código para correção. Lembrando que também sou um aspirante Rails e estou aberto para correções
neste post caso cometi alguma gafe.</p>

<h2>Referencias</h2>

<ul>
<li><a href="https://github.com/rails/rails/issues/4971">https://github.com/rails/rails/issues/4971</a></li>
<li><a href="https://github.com/rails/rails/issues/6573">https://github.com/rails/rails/issues/6573</a></li>
</ul>


<h2>Mais sobre Engine</h2>

<ul>
<li><a href="http://edgeguides.rubyonrails.org/engines.html">http://edgeguides.rubyonrails.org/engines.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Organizando as Expressões Regulares no Rails]]></title>
    <link href="http://LeandroSNunes.github.com/leandrosnunes/blog/2012/09/22/organizando-as-expressoes-regulares-no-rails/"/>
    <updated>2012-09-22T14:55:00+00:00</updated>
    <id>http://LeandroSNunes.github.com/leandrosnunes/blog/2012/09/22/organizando-as-expressoes-regulares-no-rails</id>
    <content type="html"><![CDATA[<p>No dia a dia sempre necessitamos dos super poderes das Expressões Regulares para validações de formulários, replaces em
textos e tantas outras coisas mais, alguns patterns raramente mudam de um projeto para outro, o pattern para validar e-mails
é um exemplo.</p>

<!-- more -->


<p>Pensando nisso e aproveitando a estrutura do Rails que já possui a pasta <code> /lib </code>  para armazenar nossos códigos customizados,
criei um module "ER" para ir colecionando os patterns rotineiros.</p>

<blockquote><p>Neste post estou mostrando uma solução que encontrei pois ainda desconheço se o Rails possui alguma convenção para essa tarefa.</p></blockquote>

<h2>Vamos ver a ideia!</h2>

<p>Na pasta <code> /lib </code> criei um arquivo <code> er.rb </code>  que será nosso "repositório de ERs".</p>

<p>{% codeblock ruby lang:ruby %}
module ER
  # Pattern para validação de e-mail
  EMAIL = /<sup>[<sup>@][\w.-]+@[\w.-]+[.][a-z]{2,4}$/i</sup></sup>
  # Pattern para validação de data no padrão 99/99/9999
  DATE = /<sup>(([012][0-9])|(3[01]))\/(0[1-9]|1[012])\/\d{4}$/</sup>
  # Pattern para validação de data no padrão 9999-99-99
  DATE_DB = /<sup>\d{4}-(0[1-9]|1[012])-(([012][0-9])|(3[01]))$/</sup>
  # Pattern para validação de horas sem os segungos no padrão 99:99
  TIME_H_M = /<sup>(([01]\d)|(2[0-3])):([0-5]\d)$/</sup>
  # Pattern para validação de urls, permitido os protocolos http e https
  URL = /<sup>(http|https):\/\/[a-z0-9]+([-.]{1}[a-z0-9]+)<em>.[a-z]{2,5}(([0-9]{1,5})?\/.</em>)?$/ix</sup>
end
{% endcodeblock %}</p>

<h2>Utilizando</h2>


<p>Para exemplificar, vamos validar um model User.</p>

<p>{% codeblock ruby lang:ruby %}
require 'er'
class User &lt; ActiveRecord::Base
  attr_accessible :email, :full_name
  validates :email, presence:true,  format:{with: ER::EMAIL}
end
{% endcodeblock %}</p>

<p>Perceberam a chamada do pattern? :P</p>

<p>Para validação em front-end utilizando o atributo <code> pattern </code> do HTML5, podemos reaproveitar nossos patterns, só que
precisamos de um passo a mais devido o padrão ser ER crua sem estar contida em "//" (barras).</p>

<p>Criei então um Help para fazer essa tarefa e as View continuarem fazendo apenas seu papel.
No arquivo <code> app/helpers/application_helper.rb </code>  incluir:</p>

<p>{% codeblock ruby lang:ruby %}
def er_for_html(er)
  begin</p>

<pre><code>ER.const_get(er.upcase.to_sym).source
</code></pre>

<p>  rescue NameError => exc</p>

<pre><code>"A expressao solicitada nao existe"
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>Notem que usei <code> Module#const_get </code>  para pegar a referência da constante informado e no fim o
<code> Regexp#source </code>  que retorna a string original que está envolvida por "//" <br />
Ficando no formulário:</p>

<p>{% codeblock ruby lang:ruby %}
&lt;%= f.text_field(:email, :class => :span3, :pattern => er_for_html("email"), :type => :email, :required => true, :title => "E-mail" ) %></p>

<p>{% endcodeblock %}</p>

<h2>Concluíndo</h2>


<p>É isso ai, a intenção é só para mostar uma possibilidade de organizar as coisas, claro que deve possuir outras, dessa forma,
aceito sugestões e dicas. :)</p>

<p>Para uma consulta rápida sobre metacaracteres o Aurélio disponibiliza um guia rápido <a href="http://piazinho.com.br/download/expressoes-regulares-3-tabelas.pdf" title="Ir para outra página">http://piazinho.com.br/download/expressoes-regulares-3-tabelas.pdf</a>.<br />
Para se aprofundar, leia o livro <a href="http://piazinho.com.br/" title="Ir para página do livro">Expressões Regulares - Uma abordagem divertida</a>.</p>
]]></content>
  </entry>
  
</feed>
